unit GiftWorkV2;

interface

uses
  CandyTypes, SysUtils, Math;

type
  PGiftItem = ^TGiftItem;

  TGiftItem = record
    Candy: TCandysAdr;
    Quantity: Integer;
    Next: PGiftItem;
  end;

  TGiftSolution = record
    TotalWeight: Real;
    TotalCost: Integer;
    TotalSugar: Real;
    UsedTypes: array of Integer;
    Items: PGiftItem;
  end;

  TUsedTypes = array of Integer;

  TGiftSolutions = array of TGiftSolution;

function GenerateGift(MaxWeight: Real; MaxTypes, CountGift, MaxCost: Integer;
  headCandy: TCandysAdr): TGiftSolutions;

implementation

function ContainsType(const UsedTypes: array of Integer;
  TypeKey: Integer): Boolean;
var
  i: Integer;
begin
  for i := 0 to High(UsedTypes) do
    if UsedTypes[i] = TypeKey then
    begin
      Result := True;
      Exit;
    end;
  Result := False;
end;

procedure AddGiftItem(var Head: PGiftItem; Candy: TCandysAdr;
  Quantity: Integer);
var
  TempItem: PGiftItem;
  IsBeen: Boolean;
begin
  IsBeen := false;
  TempItem := Head;
  while TempItem <> nil do
  begin
    if TempItem.Candy = Candy then
    begin
      Inc(TempItem.Quantity);
      IsBeen := true
    end;
    TempItem := TempItem^.Next;
  end;

  if not IsBeen then
  begin
    New(TempItem);
    TempItem^.Candy := Candy;
    TempItem^.Quantity := Quantity;
    TempItem^.Next := Head;
    Head := TempItem;
  end;
end;

function CloneGiftItems(Head: PGiftItem): PGiftItem;
var
  Current, NewItem, Prev: PGiftItem;
begin
  Result := nil;
  Prev := nil;
  Current := Head;
  while Current <> nil do
  begin
    New(NewItem);
    NewItem^ := Current^;
    NewItem^.Next := nil;

    if Prev = nil then
      Result := NewItem
    else
      Prev^.Next := NewItem;

    Prev := NewItem;
    Current := Current^.Next;
  end;
end;


procedure Qsort(var Data: TGiftSolutions; L, R: Integer);//; MaxWeight: Real; MaxCost: Integer);

  function ComparePresent(C1, C2: TGiftSolution):Integer;
  begin
    Result := 0;
    if C1.TotalSugar > C2.TotalSugar then
      Result := 1
    else if C1.TotalSugar < C2.TotalSugar then
      Result := -1
  end;

  procedure QuickSort(L, R: Integer);  {рекурсивная подпрограмма-процедура}
  var
    I, J: Integer;
    X, Y: TGiftSolution;
  begin
    I := L;
    J := R;
    X := Data[(L + R) div 2];


    repeat
      while ComparePresent(Data[I], X) = -1 do Inc(I);

      while ComparePresent(Data[J], X) = 1 do Dec(J);


      if I <= J then
      begin
        Y := Data[I];
        Data[I] := Data[J];
        Data[J] := Y;
        Inc(I);
        Dec(J);
      end;
    until I > J;

    if J > L then QuickSort(L, J);
    if I < R then QuickSort(I, R);
  end;

begin
  QuickSort(L, R);
end;

procedure UpdateGiftItem(var Head: PGiftItem; Candy: TCandysAdr);
var
  Current: PGiftItem;
begin
  Current := Head;
  while Current <> nil do
  begin
    if Current^.Candy^.Inf.PKey = Candy^.Inf.PKey then
    begin
      Current^.Quantity := Current^.Quantity + 1;
      Exit;
    end;
    Current := Current^.Next;
  end;

  AddGiftItem(Head, Candy, 1);
end;


function GenerateGift(MaxWeight: Real; MaxTypes, CountGift, MaxCost: Integer;
  headCandy: TCandysAdr): TGiftSolutions;
type
  TDPState = record
    TotalSugar: Real;
    TotalWeight: Real;
    TotalCost: Integer;
    UsedTypes: TUsedTypes;
    Items: PGiftItem;
  end;

function CompareSell(Old, New:TDPState;Candy: TCandysAdr): Integer;
var
  costOld,costNew: Real;
  Temp: PGiftItem;
begin
  costOld := 0;
  Temp := Old.Items;
  while Temp <> nil do
  begin
    costOld := costOld + Ln(Exp(1) + Temp.Quantity);
    Temp := Temp.Next;
  end;
  costNew:= 0;
  Temp := New.Items;
  while Temp <> nil do
  begin
    costNew := costNew + Ln(Exp(1) + Temp.Quantity + Ord(Temp.Candy.Inf.PKey = Candy.Inf.PKey));
    Temp := Temp.Next;
  end;
  if costOld > costNew then
    Result := -1
  else if costOld < costNew then
    Result := 1
  else
    Result := 0;
end;


  var
  dp: array of array of array of TDPState;
  Temp: TCandysAdr;
  t, w, c, i, j, weightInt, costInt: Integer;
  newT: Integer;
  CandyWeightInt, newWeight, newCost: Integer;
  newSugar: Real;
  newUsedTypes: TUsedTypes;
  Solutions: TGiftSolutions;
  SolutionCount: Integer;
  CandyCost: Integer;
  CurrentCandy: TCandysAdr;
begin
  weightInt := Round(MaxWeight * 100);
  costInt := Round(MaxCost / 10);

  SetLength(dp, MaxTypes + 1, weightInt + 1, costInt + 1);
  for t := 0 to MaxTypes do
    for w := 0 to weightInt do
      for c := 0 to costInt do
      begin
        dp[t][w][c].TotalSugar := -1;
        SetLength(dp[t][w][c].UsedTypes, 0);
        dp[t][w][c].Items := nil;
      end;

  dp[0][0][0].TotalSugar := 0;

  for t := 0 to MaxTypes do
    for w := 0 to weightInt do
      for c := 0 to costInt do
      begin
        if dp[t][w][c].TotalSugar < 0 then
          Continue;

        CurrentCandy := headCandy;
        while CurrentCandy <> nil do
        begin


          newT := t;
          if not ContainsType(dp[t][w][c].UsedTypes,
            CurrentCandy^.Inf.TypeCandyKet) then
            newT := t + 1;

          if newT > MaxTypes then
          begin
            CurrentCandy := CurrentCandy^.Adr;
            Continue;
          end;

          newWeight := Round((dp[t][w][c].TotalWeight + CurrentCandy^.Inf.Weigth) * 100);
          newCost := Max((Round((dp[t][w][c].TotalCost + CurrentCandy^.Inf.Cost) / 10)),1);
          newSugar := dp[t][w][c].TotalSugar + CurrentCandy^.Inf.Sugar;

          if (newWeight <= weightInt) and (newCost <= costInt) then
          begin
            if CompareSell(dp[newT][newWeight][newCost],dp[t][w][c],CurrentCandy) >= 0 then
            begin
              dp[newT][newWeight][newCost].TotalSugar := newSugar;
              dp[newT][newWeight][newCost].TotalWeight :=
                dp[t][w][c].TotalWeight + CurrentCandy^.Inf.Weigth;
              dp[newT][newWeight][newCost].TotalCost := dp[t][w][c].TotalCost +
                CurrentCandy^.Inf.Cost;

              SetLength(newUsedTypes, Length(dp[t][w][c].UsedTypes));
              for i := 0 to High(dp[t][w][c].UsedTypes) do
                newUsedTypes[i] := dp[t][w][c].UsedTypes[i];
              if not ContainsType(newUsedTypes, CurrentCandy^.Inf.TypeCandyKet)
              then
              begin
                SetLength(newUsedTypes, Length(newUsedTypes) + 1);
                newUsedTypes[High(newUsedTypes)] :=
                  CurrentCandy^.Inf.TypeCandyKet;
              end;
              dp[newT][newWeight][newCost].UsedTypes := newUsedTypes;

              dp[newT][newWeight][newCost].Items :=
                CloneGiftItems(dp[t][w][c].Items);
              AddGiftItem(dp[newT][newWeight][newCost].Items, CurrentCandy, 1);
            end;
          end;
          CurrentCandy := CurrentCandy^.Adr;
        end;
      end;

  SolutionCount := 0;
  SetLength(Solutions, 100);
   t :=  MaxTypes;
    for w := weightInt - 10 to weightInt do
      for c := costInt - 10 to costInt do
      begin
        if dp[t][w][c].TotalSugar >= 0 then
        begin
          if SolutionCount >= Length(Solutions) then
            SetLength(Solutions, Length(Solutions) * 2);

          Solutions[SolutionCount].TotalWeight := dp[t][w][c].TotalWeight;
          Solutions[SolutionCount].TotalCost := dp[t][w][c].TotalCost;
          Solutions[SolutionCount].TotalSugar := dp[t][w][c].TotalSugar;

          SetLength(Solutions[SolutionCount].UsedTypes,
            Length(dp[t][w][c].UsedTypes));
          for j := 0 to High(dp[t][w][c].UsedTypes) do
            Solutions[SolutionCount].UsedTypes[j] := dp[t][w][c].UsedTypes[j];

          Solutions[SolutionCount].Items := CloneGiftItems(dp[t][w][c].Items);
          Inc(SolutionCount);
        end;
      end;
  SetLength(Solutions, SolutionCount);

  Qsort(Solutions,Low(Solutions),High(Solutions));

  SetLength(Solutions, CountGift);
  Result := Solutions;
end;

end.
